Getting Started
=================================

Overview
---------------------------------
Pipes is a module designed in Python and converted to C and C++ via Cython. The module itself uses Finite Volume Method calculations to automatically model the filling of a water pipe based on input parameters. These input parameters are given via input and configuration files and output comes in the form of a Targa graphics file.

GitHub: https://github.com/liebannam/pipes

Installation
---------------------------------
Notes for getting installation to work on a VM with 64 bit UBUNTU
Install Anaconda: download installer from http://docs.continuum.io/anaconda/install#linux-install 

Then type::

        $ bash ~/Downloads/Anaconda3-2.4.0-Linux-x86_64.sh

Now  modify your PATH variable to look for the Anaconda distribution first, make sure to input your own username::

        $ export PATH="/home/[USERNAME]/anaconda/bin:$PATH"
		
Double check that this is where Anaconda ended up::

        $ which python2.7
		
This should return "/home/[USERNAME]/anaconda/bin/python2.7"

Now make sure that Anaconda and ipython are up to date::

        $ conda update conda
        $ conda update ipython

Install fftw2::

        $ sudo apt-get install libfftw3-dev libfftw3-doc

Install lapack, blas, and atlas::

        $ sudo apt-get install liblapack-dev
        $ sudo apt-get install liblapack
        $ sudo apt-get install liblas-dev
        $ sudo apt-get install libatlas-base-dev

Install git::

        $ sudo apt-get install git

Clone the repo::

        $ git clone https://github.com/liebannam/pipes

Set CFLAGS and ARCHFLAGS::

        $ source cython_flags.sh

Open up setup.py. Verify that you have uncommented line 46 below option
(1.3) and lines 58-59 below option (2.3) to set the environ and path
variables, make sure to input your own username. 

Compile!::

        $ python setup.py build_ext -i

Check to make sure the module loads by starting up an iypthon notebook::

        $ ipython --notebook
		
And then opening one of the notebooks in the examples/ folder. If the module
doesn't load, there is possibly a problem with the PATH variables or referencs
to the location various python modules. Double check that your path variable
points first to the Anaconda distribution by typing::

        $ echo $PATH

Then check that setup.py and allthethings.pyx have the right locations.


Use
---------------------------------
:Introduction:

There are two ways to run the code:
	
	- From command line (just compile the C++ and you're good to go)
	- From Python (requires you to build with Cython)

Requirements:
	
	- a C++ compiler (preferably gcc-4.9)
	- Open MP
	- Python
	- Cython (if you choose to run code through Python)
	- Jupyter notebook (latest version of iPython notebook)

Some things you may want:
	
	- POVRAY (if you want to make fancy plots)
	- qt_tools or ffmpeg (if you want to make movies of your fancy plots)
	- EPANET (if you want to draw networks that are complicated)
		
The original code uses two input files: .inp and .config to describe the network simulation you are running. 
	
- .INP file: 

	Possesses the same structure as a .inp file generated by the software EPANET. This has the advantage that you can use the EPANET graphical user interface to draw a big network and get the connectivities right. Or, if you have .inp files lying around from simulating them in EPANET, you can use them!

	This code is picky about how nodes are labeled, so if you do use an EPANET-generated file, you need to run the python script (which lives in indata) to rewrite it with acceptable numbering. To do this, just run::
	
		python cleanupinpfiles.py nameoforiginalinpfile.inp

	This generates a new file called nameoforiginalinpfile2.inp which you can use for this code.
		
- .CONFIG file:

	Not all the things the intermittency scenario needs to know about will be described in an EPANET inp file. So I have created a .config file which contains other information, such as boundary conditions, number of grid cells, simulation time, pressure wave speed, and number of time steps.

The output data goes to a directory called output_data, which the code assumes exists. If you're starting from scratch, you'll need to make this directory.
	
For the python interface, I have made some helper functions to avoid having to deal with .inp and .config files all the time (e.g. when changing a parameter and rerunning the code many times.). Those functions are found in the module writeit.py, whose use can be examined in, e.g. VaryLength.ipynb.

|

:Calling from Command Line:
	
Why would you want use the code from command line?
	
	It's probably simpler and faster to compile, for one thing. It's also easier to add new features to the code and test them. Lastly, some of the features of the original code (such as writing out data to make into movies) has not been wrapped for calling from Python.

Getting started...
	
- Go to the folder pipes. In this folder, you should have a folder called "output_data". If you don't have this, your simulation will crash when it tries to write output data there, so run mkdir output_data if it's not there yet. If it existed already, clear out all the files so that you don't get old data mixed up with the stuff you're about to generate. 
		
- Go to the folder called Build
	
- The compilation information is in the file called Makefile and the supporting info is in the file called Sysdep. Quite frankly, I think compiling is voodoo magic, so if it's not compiling for you, then all I have to say is "good luck, have fun".
	
- To run a simulation, you want to use the driver routine "justrunit.cpp". so you would compile as follows::
	
	make justrunit
	
- You can also compile the optimization stuff using make optimizeit (to do optimizaiton stuff...but that cpp file may be outdated after some cython-related source code changes).
	
- Calling syntax is::

	./justrunit nameofinpfile.inp  nameofconfigfile.config
		
- If your simulation is crashing, one simple debug stragegy is to crank down the number of time steps. Or, set the flag WTF = 1. This prints a lot of random information about what's going on.
	
After you run a simulation, you can make really pretty figures out of the data you generated in output_data

|

:Calling from Python:

Why would you want use the code from Python?
	
	It's easier to play with parameters and data visualization. You can make lovely figures, change parameters, dig in and look at the data in your networks to verify that it is what you think it is.
		
Getting started...
	
	You will need to use Cython to compile the C++ code into a Python module. I suggest using the Anaconda distribution of Python and gcc-4.9. You will need to specify the path to the gcc compiler you are using, and your Anaconda distribution, in the setup.py file. Look in this file to see examples of how those locations are referenced.
        
To compile, first run::
                
    source cython_flags.sh
 
Setting compiler flags. Then run::

	Python setup.py build_ext -i

To actually compile the module. There are a couple things that usually go wrong here:

1. Clang butts in and pretends to be GCC, which means that omp.h can't be found. Force the compiler to be gcc-4.9 so this doesn't happen. 

2. The Cython bit gets confused and tries to pass Clang-specific flags anyway. So if you get the following error::

	gcc-4.9: error: unrecognized command line option '-Wshorten-64-to-32'

Then try running the following commands in your terminal (these sould have been set by the cython_flags.sh script, but just in case)::
		
	export ARCHFLAGS="" 
	export CFLAGS = "-arch i386 -arch x86_64" 

Lots of other things can go wrong, dig in to the file setup.py to look at compilation paths and flags. I have commented out and labeled the lines that work on my own system--you will need to specify your own paths to gcc and Python for your own setup.
	
The file allthethings.pyx has all the actual wrapping for the C++ code. It's a bit of a mess but I did try to document all the classes you would use in a Python call to do something interesting (e.g. run a simulation of a network or run an optimization.)

Once you compile...
	
1. Give yourself a high-five!
	
2. You can either use Python scripts or notebooks to call the C++ code. I personally like notebooks so all the examples are in .ipynb form. But there's no reason you can't use a Python script to do the exact same thing if you like.
	
3. Check to make sure compiled module allthethings actually works. Sometimes it compiles but can't load or link libraries, which means you should go back to beginning and figure out compiler issues.

4. There are a lot of notebooks, many correspond to examples in the paper. You can use them to see some of the calling syntax and possible uses. 

	- Beginner
		- Pipe_tutorial.ipynb: START HERE! Intro to basic code setup and functionanlity.
		- Intro_simulation_7deSeptiembre.ipynb: run a realistic network from existing .inp and .config files.
		- Intro_simulation_Alameda.ipynb: run a realistic network; reset some network parameters by using writeit.py to rewrite new .inp and .config files
				
	- Intermediate
		- Water_hammer.ipynb: simulate a water hammer in pressurized pipe, check results against textbook waterhammer formula
		- Trajkovic_new.ipynb: simulate pressurization in a single pipe and compare results with dataset
				
	- More advanced (less commented)
		- Cythondemo.ipynb (just shows lots of stuff you can do with the wrapped code)
		- Convergence.ipynb (do a convergence study)
		- VaryLength.ipynb (vary length of one pipe and simulate new network. Demonstrates using the module writeit.py to make networks without touching .config or .inp files)
		- MysteryBC.ipynb (optimize to fit unknown BC)
		- ReallyoptimizeDH.ipynb (optimize dh/dx by controlling boundary inflow at one node)
		
5. You can run a notebook on your own machine just by starting one up::
	
	ipython noteboook
	
6. You can also run one remotely, which is really nice if you are having trouble compiling the code on a different machine (or dont' want to run a big simulation there). To do this, you start one ssh pipe as follows::

	ssh -N -f -L localhost:8889:localhost:8889  yourname@remote_server.org

Then you start a new terminal, and ssh in normally::
	
	ssh yourname@remote_server

And once you're logged in to your remote server, you start up a notebook with no browser, which instead points to the pipe you already made::

	ipython notebook --no-browser --port=8889

Now go to your browser (on your machine!) and enter the address::

	http://localhost:8889

You should see the usual ipython notebook tree. You can run cells and make
plots--but the remote server is doing the work. 

After you run a simulation
You can sit all day and make pretty figures in matplotlib. With text labels!


:Dealing With All the Data!:

After you run a command line simulation::

	./justrunit blah.inp blah.config

you will have filled up the folder output_data with a bunch of .txt and .tga
files. You should never ever have to deal with them directly!

The python script smarterputittogether.py and blockputittogether.py do the
work of writing povray scripts and running them to create images.
Smartputitogether.py can do either a topview (with false colors for pressure)
or an angleview (with pretty glass pipes!).

Notes on this:

1. Make a folder called movie if it's not already there-- that's where these scripts write the image files to.

2. Before you run either of these scripts, open them and comment out the line that says os.sys. This prevents you from running 100 or 300 povray renderings before you know if you like the colors, view, etc.

3. Also check that the number of writes is correct (it should correspond to the number of .tga files in the output_data folder)

4. Once the os.sys(command) bit is commented out, run the python script and use povray angleview.pov or povray topview.pov to generate a test figure. You may want to tweak the view or color scheme--those properties are in topview.pov and angleview.pov.

5. When you like the test figure, uncomment the line from step (1). Run the script, go get some coffee and put on a movie...rendering is slow!

Go to the folder movie and you can then stitch the together with qt_tools, for example: quick time movies with qt_tools::
	
	qt_export --sequencerate=15 tmp_000.png --dodialog test3again.mov

Or with ffmpeg::

	ffmpeg -f image2 -i tmp_%03d.png -vcodec libx264 -b 2400k output-filename.mp4

